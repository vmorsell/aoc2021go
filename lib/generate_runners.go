package lib

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"text/template"
)

type runnerParams struct {
	BaseName   string
	InputType  string
	ResultType string
}

func GenerateRunners(name string, path string) error {
	src, err := ioutil.ReadFile(fmt.Sprintf("%s/%s.go", path, name))
	if err != nil {
		log.Fatalf("read file: %v", err)
	}

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, "", string(src), parser.ParseComments)
	if err != nil {
		log.Fatalf("parse file: %v", err)
	}

	params := runnerParams{
		BaseName: name,
	}

	for _, d := range f.Decls {
		fn, ok := d.(*ast.FuncDecl)
		if !ok {
			continue // Not a function
		}

		if fn.Name.Name == "parse" {
			typ, err := firstFieldType(fn.Type.Results)
			if err != nil {
				log.Fatalf("parse: %v", err)
			}
			params.InputType = typ
		}

		if fn.Name.Name == "part1" {
			typ, err := firstFieldType(fn.Type.Results)
			if err != nil {
				log.Fatalf("parse: %v", err)
			}
			params.ResultType = typ
		}

	}

	templates := []struct {
		name string
		tpl  string
	}{
		{
			name: "runners_gen.go",
			tpl:  runnersTpl,
		},
		{
			name: "runners_gen_test.go",
			tpl:  testTpl,
		},
	}
	for _, t := range templates {
		w, err := os.Create(fmt.Sprintf("%s/%s", path, t.name))
		if err != nil {
			return fmt.Errorf("create %s: %w", t.name, err)
		}
		defer w.Close()

		tpl := template.Must(template.New(t.name).Parse(t.tpl))
		if err := tpl.Execute(w, params); err != nil {
			return fmt.Errorf("execute %s: %w", t.name, err)
		}
	}
	return nil
}

func firstFieldType(fl *ast.FieldList) (string, error) {
	if fl == nil {
		return "", fmt.Errorf("missing field list")
	}
	if len(fl.List) == 0 {
		return "", fmt.Errorf("field list is empty")
	}

	f := fl.List[0]
	typ, err := fieldType(f.Type)
	if err != nil {
		return "", fmt.Errorf("field type: %w", err)
	}
	return typ, nil
}

func fieldType(expr ast.Expr) (string, error) {
	switch typ := expr.(type) {
	case *ast.Ident:
		return typ.Name, nil
	case *ast.ArrayType:
		t, err := fieldType(typ.Elt)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("[]%s", t), nil
	case *ast.Ellipsis:
		t, err := fieldType(typ.Elt)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("[]%s", t), nil
	case *ast.StarExpr:
		t, err := fieldType(typ.X)
		if err != nil {
			return "", err
		}
		return t, nil
	case *ast.MapType:
		k, err := fieldType(typ.Key)
		if err != nil {
			return "", err
		}
		v, err := fieldType(typ.Value)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("map[%s]%s", k, v), nil
	case *ast.SelectorExpr:
		x, err := fieldType(typ.X)
		if err != nil {
			return "", err
		}
		sel, err := fieldType(typ.Sel)
		if err != nil {
			return "", err
		}
		return fmt.Sprintf("%s.%s", x, sel), nil
	case *ast.InterfaceType:
		return "interface{}", nil
	case *ast.FuncType:
		return "func", nil
	}
	return "", fmt.Errorf("unknown type %T", expr)
}

var runnersTpl = `// Code generated by lib/generate_runners.go; DO NOT EDIT

package main

import (
	"fmt"
	"io"
	"log"
	"os"
)

func main() {
	if err := run("{{ .BaseName }}.in", parse, part1, part2); err != nil {
		log.Fatal(err)
	}
}

type parseFn func(r io.Reader) ({{ .InputType }}, error)
type execFn func(input {{ .InputType }}) ({{ .ResultType }}, error)

func run(path string, parse parseFn, execFuncs ...execFn) error {
	if parse == nil {
		return fmt.Errorf("missing parser")
	}

	file, err := os.Open(path)
	if err != nil {
		return fmt.Errorf("open: %w", err)
	}
	defer file.Close()

	input, err := parse(file)
	if err != nil {
		return fmt.Errorf("parse: %w", err)
	}

	for i, fn := range execFuncs {
		res, err := fn(input)
		if err != nil {
			return fmt.Errorf("exec fn %d: %w", i, err)
		}
		fmt.Println(res)
	}
	return nil
}
`

var testTpl = `// Code generated by lib/generate_runners.go; DO NOT EDIT

package main

import (
	"os"
	"testing"

	"github.com/stretchr/testify/require"
)

type test struct {
	name string
	fn   execFn
	want {{ .ResultType }}
}

func Test(t *testing.T) {
	tests := []test{
		{
			name: "part 1",
			fn: part1,
			want: wantPart1Test,
		},
		{
			name: "part 2",
			fn: part2,
			want: wantPart2Test,
		},
	}
	runTests(t, "{{ .BaseName }}.test", parse, tests...)
}

func runTests(t *testing.T, path string, parse parseFn, tests ...test) {
	require.NotNil(t, parse)

	require.NotNil(t, path)
	file, err := os.Open(path)
	require.Nil(t, err)
	defer file.Close()

	input, err := parse(file)
	require.Nil(t, err)

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			res, err := tt.fn(input)
			require.Nil(t, err)
			require.Equal(t, tt.want, res)
		})
	}
}
`
